package de.hu_berlin.ensureII.sre.parser;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Stack;
import java.util.concurrent.Callable;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import de.hu_berlin.ensureII.sre.grammar.NonTerminal;
import de.hu_berlin.ensureII.sre.grammar.ProductionRule;
import de.hu_berlin.ensureII.sre.grammar.SRE_Grammar;
import de.hu_berlin.ensureII.sre.grammar.Symbol;
import de.hu_berlin.ensureII.sre.grammar.Token;
import de.hu_berlin.ensureII.sre.lexer.ILexer.LexException;
import de.hu_berlin.ensureII.sre.lexer.SRE_Lexer;
import de.hu_berlin.ensureII.sre.parser.attributes.SREConfig;
import de.hu_berlin.ensureII.sre.parser.reducer.SRE_Reducer;
import de.hu_berlin.ensureII.sre.parser.reducer.SRE_Reducer.ReduceException;
import de.hu_berlin.ensureII.sre.parser.sretree.SRETree;
import de.hu_berlin.ensureII.sre.parser.sretree.SRETreeNode;
import de.hu_berlin.ensureII.sre.parser.sretree.builder.ISRETreeBuilder;
import de.hu_berlin.ensureII.sre.parser.sretree.builder.SRETreeBuilder;
import de.hu_berlin.ensureII.sre.parser.sretree.calculator.ISRETreeCalculator;
import de.hu_berlin.ensureII.sre.parser.sretree.calculator.SRETreeCalculator;


public class SRE_Parser implements Callable<SRETreeNode>{

    /**
     * An operator precedence parser for stochastic regular expressions.
     * 
     */
	
/*****************************************************************************
** Constructors
*****************************************************************************/
    
    public SRE_Parser(List<String> searchString, SREConfig cfg, ISRETreeBuilder builder, ISRETreeCalculator calc) {
        
        this.cfg = cfg;
        this.searchString = searchString;
        
        lexer = new SRE_Lexer();
        grammar = new SRE_Grammar();
        symbolStack = new Stack<Symbol>();
        tokenStack = new Stack<Token>();
        reducer = new SRE_Reducer();
        treeNodeStack = new Stack<SRETreeNode>();
        sreTreeBuilder = builder;
        sreTreeCalculator = calc;
                
    }
    
	public SRE_Parser(List<String> searchString, SREConfig cfg) {
		this(searchString, cfg, new SRETreeBuilder(), new SRETreeCalculator(searchString));
	}
	
	public SRE_Parser(List<String> searchString, SREConfig cfg, ISRETreeBuilder builder) {
	    this(searchString, cfg, builder, new SRETreeCalculator(searchString));
    }
	
	public SRE_Parser(List<String> searchString, SREConfig cfg, ISRETreeCalculator calc) {
	    this(searchString, cfg, new SRETreeBuilder(), calc);
    }
	
	/**
	 * Constructor for helping to implement the Callable interface. Allows to set the string to parse
     * here in the constructor.
	 * 
	 * @param input
	 * @param searchString
	 * @param cfg
	 * @param builder
	 * @param calc
	 */
	public SRE_Parser(String input, List<String> searchString, SREConfig cfg, ISRETreeBuilder builder, ISRETreeCalculator calc) {
	    this(searchString, cfg, builder, calc);
	    this.input = input;
    }
	
/*****************************************************************************
** Parsing
*****************************************************************************/
	
	/**
	 * Parse the input and save the AST from the last parsing.
     * 
	 * @param input
	 * @return
	 */
	public SRETreeNode parse(String input) {
	    
	    /****************************************************************************/
        if(input == null){
            throw new IllegalArgumentException("Input must be non null.");
        }
        /****************************************************************************/
        sreTreeBuilder.setTree(new SRETree());
        //////////////////////////////////////////////////////////////////////////////
	    //logger.debug("PARSING: {}", input);
        //////////////////////////////////////////////////////////////////////////////
        
	    //remove all whitespaces
        input = input.replaceAll("\\s", "");
	    List<Token> tokens = new ArrayList<Token>();
        
	    try{
            tokens = lexer.tokenize(input);
        }catch(LexException e){
            e.printStackTrace();
        }
	    
        lastAST = currentAST;
	    
        SRETreeNode ast = parse(tokens);
	    
	    currentAST = ast;
	    sreTreeBuilder.getTree().setRoot(ast);
	    
	    return ast;
	}
	
	/**
	 * Parse the string using the tokens generated by the lexer.
	 * When we execute the reduce operation we also build the syntax tree
	 * bottom up from the leafs.
	 */
	protected SRETreeNode parse(List<Token> tokens){
		
	    /****************************************************************************/
		assert(symbolStack.isEmpty());
		assert(tokenStack.isEmpty());
		assert(treeNodeStack.isEmpty());
		assert(tokens != null);
		/****************************************************************************/
		
		//////////////////////////////////////////////////////////////////////////////
		//logger.debug("Tokenstream {}", tokens);
		//////////////////////////////////////////////////////////////////////////////
		
		if(tokens.size() == 0) {
		    System.err.println("Empty string not in the language.");
            System.exit(-1);
		}
		
		boolean parsing = true;
		int precedence;
		Token currentInputToken;
		NonTerminal lhs;
		int nextToken = 0;
		
		symbolStack.push(SRE_Grammar.eofToken);
		tokenStack.push(SRE_Grammar.eofToken);
		currentInputToken = tokens.get(nextToken++);
		
		while(parsing){
		    //////////////////////////////////////////////////////////////////////////////
		    logger.debug("Next Token '{}'", currentInputToken);
		    //////////////////////////////////////////////////////////////////////////////
			if(currentInputToken.equals(SRE_Grammar.eofToken) && tokenStack.peek().equals(SRE_Grammar.eofToken)){
				if(symbolStack.peek().equals(grammar.getS())){
				    //////////////////////////////////////////////////////////////////////////////
					logger.debug("Reduced to start symbol {} and no more Tokens left. Parse successful.", grammar.getStartSymbol());
				    //////////////////////////////////////////////////////////////////////////////
					parsing = false;
				}else{
					try{
					    lhs = reduce(currentInputToken);
					    symbolStack.push(lhs);
					}catch(ReduceException e) {
					    //////////////////////////////////////////////////////////////////////////////
					    logger.error(e.errMsg());
					    logger.error("Parsing failed at '{}'", currentInputToken);
					    //////////////////////////////////////////////////////////////////////////////
					    e.printStackTrace();
					    System.exit(-1);
					}
				}
			}else{
				precedence = grammar.getPrecedence(tokenStack.peek(), currentInputToken);
				
				if(precedence == -1 || precedence == 2){ 
				    //////////////////////////////////////////////////////////////////////////////
				    logger.debug("SHIFTING: last token '{}' <= '{}' next token", tokenStack.peek(), currentInputToken);
				    //////////////////////////////////////////////////////////////////////////////
				    
					symbolStack.push(currentInputToken);
					tokenStack.push(currentInputToken);
					currentInputToken = tokens.get(nextToken++);
					
				}else if(precedence == 1){ 
				    //////////////////////////////////////////////////////////////////////////////
				    logger.debug("REDUCE: last token '{}' > '{}' next token.", tokenStack.peek(), currentInputToken);
				    //////////////////////////////////////////////////////////////////////////////
				    
					try{
					    lhs = reduce(currentInputToken);
					    symbolStack.push(lhs);
					}catch(ReduceException e) {
                        //////////////////////////////////////////////////////////////////////////////
                        logger.error(e.errMsg());
                        logger.error("Parsing failed at '{}'", currentInputToken);
                        //////////////////////////////////////////////////////////////////////////////
                        e.printStackTrace();
                        System.exit(-1);
                    }
				}else{ 
				    //////////////////////////////////////////////////////////////////////////////
				    logger.error("Parsing failed at '{}'", currentInputToken);
				    //////////////////////////////////////////////////////////////////////////////
					System.exit(-1);
				}
			}
		}
		
		SRETreeNode ast = treeNodeStack.pop();
		
		/****************************************************************************/
		assert(symbolStack.peek().equals(grammar.getS()));
		assert(currentInputToken.equals(SRE_Grammar.eofToken));
		/****************************************************************************/
		
		symbolStack.clear();
        tokenStack.clear();
		
		return ast;
	}

	/**
	 * As long as the last token we parsed does not have lower precedence to the
	 * current input token, i.e. the next token we want to parse, add the symbols 
	 * we parsed one after the other to the handle. Reduce the handle to a 
	 * nonterminal according to the grammar.  
	 * 
	 * @param inputToken
	 * 			The current input token.
	 * @return
	 * 			The nonterminal after reducing.
	 */
	private NonTerminal reduce(Token inputToken) throws ReduceException{
		
	    /****************************************************************************/
	    assert(inputToken != null);
		assert(grammar.getPrecedence(tokenStack.peek(), inputToken) == 1);
		/****************************************************************************/
		
		List<Symbol> handle = getReductionHandle(inputToken);
		int reductionRuleId;
		
		try {
		    reductionRuleId = reducer.getReductionRule(handle);
		}catch(ReduceException e) {
		    throw e;
		}
		
		ProductionRule rule = grammar.getProductionRule(reductionRuleId);
        
        SRETreeNode ast = buildAST(reductionRuleId, handle);
        if(ast.getData() == null) {
            sreTreeCalculator.calculateNodeData(ast);
        }
        treeNodeStack.push(ast);
        
        NonTerminal reduction = rule.lhs();
        
        /****************************************************************************/
        assert(SRE_Grammar.sameRhs(rule.rhs(), handle));
        /****************************************************************************/
        
        return reduction;
		
	}
	
	private List<Symbol> getReductionHandle(Token inputToken) {
	    
	    /****************************************************************************/
        assert(inputToken != null);
        assert(grammar.getPrecedence(tokenStack.peek(), inputToken) == 1);
        /****************************************************************************/
        
        int precedence = 1;
        Token rightmostToken = inputToken;
        LinkedList<Symbol> handle = new LinkedList<Symbol>();
        
        /* pop until we can reduce, i.e. the topmost token yields precedence
         * and there are no more Nonterminals to pop
         */
        while(precedence != -1 ||
                (precedence == -1 && symbolStack.peek().getClass().equals(NonTerminal.class))){
            
            if(symbolStack.peek().getClass().equals(NonTerminal.class)){
                //ignore precedence for NonTerminals
                handle.addFirst(symbolStack.pop());
            }else{
                //pop token and check precedence
                if(symbolStack.peek().equals(SRE_Grammar.eofToken)) break;
                
                rightmostToken = (Token) symbolStack.pop();
                
                /****************************************************************************/
                assert(rightmostToken.equals(tokenStack.peek()));
                /****************************************************************************/
                
                tokenStack.pop();
                handle.addFirst(rightmostToken);
                precedence = grammar.getPrecedence(tokenStack.peek(), rightmostToken);
            }
        }
        
        return handle;
	    
	}
	
	/**
     * Syntax directed construction of the AST.
     * 
     * @param handle
     *      The handle we construct the AST from. The ruleID is not
     *      enough because we need the tokens from action, weight and
     *      probability.
     * @param ruleId
     *      The production rule id for reducing the handle and therefore
     *      for constructing the AST.
     */
    private SRETreeNode buildAST(int ruleId, List<Symbol> handle){
        
        /****************************************************************************/
        assert(grammar.ruleExists(ruleId));
        assert(SRE_Grammar.sameRhs(grammar.getProductionRule(ruleId).rhs(), handle));
        /****************************************************************************/
        
        //////////////////////////////////////////////////////////////////////////////
        logger.debug("{} is getting reduced to {}", handle, grammar.getProductionRule(ruleId).lhs());
        //////////////////////////////////////////////////////////////////////////////
        
        SRETreeNode node = sreTreeBuilder.buildSRETreeFromProductionRule(ruleId, handle, treeNodeStack);
        
        /****************************************************************************/
        assert(treeCorrespondsToRule(node, ruleId));
        /****************************************************************************/
        
        return node;
    }

/*****************************************************************************
** Implement Callable
*****************************************************************************/
    
    @Override
    public SRETreeNode call() {
        return parse(input);
    }
    
/*****************************************************************************
** Attributes
*****************************************************************************/
	
	protected SREConfig cfg;
	
	protected List<String> searchString;
	
	protected String input;
	
	protected SRE_Lexer lexer;

	protected SRE_Grammar grammar;
	
	private Stack<Symbol> symbolStack;
	
	private Stack<Token> tokenStack;
	
	private SRE_Reducer reducer;
	
	private Stack<SRETreeNode> treeNodeStack;
	
	public ISRETreeBuilder sreTreeBuilder;
	
	public ISRETreeCalculator sreTreeCalculator;
	
	protected SRETreeNode currentAST;
	
	private SRETreeNode lastAST;
    
/*****************************************************************************
** Setter and Getter
*****************************************************************************/

    public SRETreeNode currentAST() {
        return currentAST;
    }
    
    public SRETreeNode lastAST() {
        return lastAST;
    }
    
/*****************************************************************************
** Assertions
*****************************************************************************/
    
    public static boolean treeCorrespondsToRule(SRETreeNode node, int ruleId) {
        boolean result = true;
        
        switch(ruleId){
        case 0: //S -> E
            //nothing
            break;
        case 1: //E -> E1 : E2
            result = node.getType().equals(SRETreeNode.Type.CONCAT) &&
            node.getChildren().size() > 1;
            break;
        case 2: //E -> E1*p
            result = node.getType().equals(SRETreeNode.Type.KLEENE) &&
            node.getChildren().size() == 1;
            break;
        case 3: //E -> E1#p
            result = node.getType().equals(SRETreeNode.Type.CLOSURE) &&
            node.getChildren().size() == 1;
            break;
        case 4: //E -> (E1)
            //nothing
            break;
        case 5: //E -> (C)
            //nothing
            break;
        case 6: //E -> action
            result = node.getType().equals(SRETreeNode.Type.ACTION);
            break;
        case 7: //C -> C1 + C2 
            result = node.getType().equals(SRETreeNode.Type.CHOICE) &&
                node.getChildren().size() > 1;
            break;
        case 8: //C -> E[w]
            //nothing
            break;
        default:
            result = false;
        }
        
        return result;
    }

/*****************************************************************************
** Logging
*****************************************************************************/
    
    final Logger logger = LoggerFactory.getLogger(SRE_Parser.class);
    
}
